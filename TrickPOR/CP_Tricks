cumilitive sum(csum) of matrix (1,1) to (i,j) csum[i][j]=csum[i-1][j]+csum[i][j-1]-csum[i-1][j-1]+matrix[i][j]
query of any sum of rectangle(x1,y1,x2,y2)=csum[x2][y2]-csum[x2][y1-1]-csum[x1-1][y2]+csum[x1-1][y1-1];


Rotate by 45 degree to linearize distance:
Eg if distance between two points is given as max(abs(x1-x2),abs(y1-y2))
it can be written in form summation form by changing cordinate x1=(x1+y1),y1=(x1-y1)
distance will be (abs(x1-x2)+abs(y1-y2))/2;
//https://atcoder.jp/contests/abc351/tasks/abc351_e


Re-root the tree technique.
first caluclate by subtree rooting in dfs , and then calcuate the re-rooted value by second dfs
//https://cses.fi/problemset/result/7013514/



when finding max/min after operation on strings 
see what string will look like when no operations can be performed on it.Eg:https://www.codechef.com/START133A/problems/ABCC3


when two parameters are there in greedy, may be sort by one and use heap/multiset on other parameter.
Eg:https://leetcode.com/problems/minimum-cost-to-hire-k-workers/?envType=daily-question&envId=2024-05-11 


when on ith move we can move by +i or -i, then minimum steps to reach a point p is,
let d(x)=(x*x+x)/2  and d(x) >=p , if differnece between d(x)-p is even and less than x then in atmost 1 extra jump exactly p can be achieved.

permutation cycles, edge between i and p[i], graph is a componenet, where each component is a simple cycle.


For these type of questions https://codeforces.com/blog/entry/129410 
Every subarray the first and last element should be min or max
Every subarray should be monotonically increasing or decreasing

Lexicographically least topsort , instead of queue use priortiy queue in regular topsort algo

In row and column operations, think if anyone can be done first
https://leetcode.com/problems/score-after-flipping-matrix/description/?envType=daily-question&envId=2024-05-13


counts how mant times a edge will be used, to count the number of operations.
https://leetcode.com/problems/distribute-coins-in-binary-tree/submissions/1260964237/?envType=daily-question&envId=2024-05-18




top set bottom set trick for median running or top k type of queries with updates.
maintain multisets of elements.


Multisource bfs-https://www.codechef.com/problems/PRISON


//identity
x+y = (x^y) + 2(x&y)
floor((x^y)/2)=floor((x/2) ^ (y/2))=floor(x/2) ^ floor(y/2)
x < y < z  we always have min(x^y, y^z) < x^z. 
any set of integers, 
the minimum bitwise XOR between some pair of them will always be obtained by some adjacent pair in sorted order.

piegonhole principle