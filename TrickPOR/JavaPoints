Java Streams are a new abstraction introduced in Java 8, allowing functional-style operations on sequences of elements. 
They enable parallel processing and make it easy to write clean and concise code for bulk operations, like filtering, mapping, and reducing collections of data.

What is the difference between intermediate and terminal operations in streams?

Answer:
Intermediate operations: Return a new stream and are lazily executed (e.g., filter, map, sorted).
Terminal operations: Trigger the processing of the stream and return a result or side-effect (e.g., collect, forEach, reduce).
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

List<String> list = Arrays.asList("apple", "banana", "apricot");
List<String> result = list.stream()
                          .filter(s -> s.startsWith("a"))
                          .collect(Collectors.toList());


List<String> list = Arrays.asList("a", "b", "c");
List<String> upperCaseList = list.stream()
                                 .map(String::toUpperCase)
                                 .collect(Collectors.toList());


A functional interface is an interface with a single abstract method, and it can be implemented using a lambda expression or method reference. 
Examples include Runnable, Callable, Comparator, and custom interfaces annotated with @FunctionalInterface.
Function<String, Integer> lengthFunction = String::length;
int length = lengthFunction.apply("Hello");
Function<String, Integer> lengthFunction = String::length;

The Predicate interface represents a predicate (boolean-valued function) of one argument. It has a method test.
Predicate<String> isEmpty = String::isEmpty;
boolean result = isEmpty.test("");

Supplier: Represents a supplier of results, takes no arguments, and returns a result.
Supplier<String> supplier = () -> "Hello, World!";
String result = supplier.get();

Consumer: Represents an operation that accepts a single input argument and returns no result.
Consumer<String> consumer = System.out::println;
consumer.accept("Hello, World!");

class Interval implements Comparable<Interval>{
    int start,end;
    Interval(int start,int end){
        this.start=start;
        this.end=end;
    }

    @Override
    public int compareTo(Interval other) {
        return this.end-other.end;
    }
}

public int eraseOverlapIntervals(int[][] intervals) {
        List<Interval> events= new ArrayList<>();
        int n=intervals.length;
        for(int i=0;i<n;i++){
            events.add(new Interval(intervals[i][0],intervals[i][1]));
        }

        Collections.sort(events);

        int ending_curr=Integer.MIN_VALUE,ans=0;

        for(Interval i:events){
            if(i.start >= ending_curr){
                ans++;
                ending_curr=i.end;
            }
        }
        

        return n-ans;
    }


//stringbuilder create smutable string.
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
sb.insert(5, " World");
sb.delete(5, 11);// sb now contains "Hello"
sb.deleteCharAt(5);
sb.replace(6, 11, "Java");// sb now contains "Hello Java"
sb.reverse();
String str = sb.toString();
char ch = sb.charAt(1);
sb.setCharAt(1, 'a');
String sub = sb.substring(6, 11);
int len = sb.length();
sb.indexOf(b)=checks if b is substring of a

//Iterator examples
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Cherry");

Iterator<String> iterator = list.iterator();

while (iterator.hasNext()) {
    String fruit = iterator.next();
    System.out.println(fruit);
}


//Queue
ueue<String> queue = new LinkedList<>();

queue.add("Apple");
queue.add("Banana");
queue.add("Cherry");

System.out.println("Queue: " + queue);
System.out.println("Poll: " + queue.poll()); // Retrieves and removes the head (Apple)
System.out.println("Queue after poll: " + queue);
System.out.println("Peek: " + queue.peek()); // Retrieves the head without removing (Banana)
System.out.println("Queue after peek: " + queue);

//Deque
Deque<String> deque = new ArrayDeque<>();

deque.addFirst("Apple");
deque.addLast("Banana");
deque.addFirst("Cherry");

System.out.println("Deque: " + deque);
System.out.println("Remove First: " + deque.removeFirst()); // Cherry
System.out.println("Deque after removeFirst: " + deque);
System.out.println("Remove Last: " + deque.removeLast()); // Banana
System.out.println("Deque after removeLast: " + deque);
System.out.println("Peek First: " + deque.peekFirst()); // Apple
System.out.println("Peek Last: " + deque.peekLast()); // Apple


//Priority Queue
Queue<Integer> priorityQueue = new PriorityQueue<>();
Queue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());//Creating a max-heap using a custom comparator

priorityQueue.add(10);
priorityQueue.add(20);
priorityQueue.add(15);

System.out.println("PriorityQueue: " + priorityQueue);
System.out.println("Poll: " + priorityQueue.poll()); // Retrieves and removes the head (10)
System.out.println("PriorityQueue after poll: " + priorityQueue);
System.out.println("Peek: " + priorityQueue.peek()); // Retrieves the head without removing (15)
System.out.println("PriorityQueue after peek: " + priorityQueue);

//Peak and poll return null when queue is empty
with custom comparator
import java.util.Comparator;

class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.getAge(), p2.getAge());
    }
}
PriorityQueue<Person> priorityQueue = new PriorityQueue<>(new AgeComparator());



//stack
Stack<Integer> stack = new Stack<>();

// Push elements onto the stack
stack.push(10);
stack.push(20);
stack.push(30);

// Display the stack
System.out.println("Stack: " + stack); // Output: [10, 20, 30]

// Peek at the top element
System.out.println("Peek: " + stack.peek()); // Output: 30

// Pop the top element
System.out.println("Pop: " + stack.pop()); // Output: 30
System.out.println("Stack after pop: " + stack); // Output: [10, 20]


//Java linked list
LinkedList class is part of the Java Collections Framework and implements both the List and Deque interfaces,
providing a doubly-linked list implementation. This allows it to be used as a list, stack, queue, or deque.

LinkedList<String> linkedList = new LinkedList<>();
// Adding elements to the LinkedList
linkedList.add("A");
linkedList.add("B");
linkedList.add("C");
linkedList.add("D");
System.out.println("Initial LinkedList: " + linkedList); // Output: [A, B, C, D]

// Adding an element at a specific position
linkedList.add(2, "E");
System.out.println("After adding 'E' at index 2: " + linkedList); // Output: [A, B, E, C, D]

// Removing an element
linkedList.remove("B");
System.out.println("After removing 'B': " + linkedList); // Output: [A, E, C, D]

// Getting an element
String element = linkedList.get(1);
System.out.println("Element at index 1: " + element); // Output: E


//Set in Jvaa


Set<String> hashSet = new HashSet<>();
// Adding elements to the HashSet
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Cherry");
hashSet.add("Date");
hashSet.add("Apple"); // Duplicate element

// Displaying the HashSet
System.out.println("HashSet: " + hashSet); // Output order is not guaranteed
// Output: HashSet: [Banana, Date, Apple, Cherry] (order may vary)

// Checking if an element exists
System.out.println("Contains 'Banana': " + hashSet.contains("Banana")); // Output: true

// Removing an element
hashSet.remove("Banana");
System.out.println("HashSet after removing 'Banana': " + hashSet);

//TreeSet
Set<String> treeSet = new TreeSet<>();

// Adding elements to the TreeSet
treeSet.add("Apple");
treeSet.add("Banana");
treeSet.add("Cherry");
treeSet.add("Date");
treeSet.add("Apple"); // Duplicate element

// Displaying the TreeSet
System.out.println("TreeSet: " + treeSet); // Elements are sorted
// Output: TreeSet: [Apple, Banana, Cherry, Date]

// Checking if an element exists
System.out.println("Contains 'Banana': " + treeSet.contains("Banana")); // Output: true

// Removing an element
treeSet.remove("Banana");
System.out.println("TreeSet after removing 'Banana': " + treeSet); // Output: [Apple, Cherry, Date]

HashSet: Allows one null element.
TreeSet: Does not allow null elements.

// Iterate
for (Person person : people) {
    System.out.println(person);
}

Creating a HashSet of Custom Objects-Ensure that your class overrides the equals and hashCode methods.

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age && Objects.equals(name, person.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}


Creating a TreeSet of Custom Objects-Ensure that your class implements the Comparable interface or provide a Comparator.

class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters (optional)
    
    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name); // Sorting by name
    }
};


public static Comparator<Person> ageComparator = new Comparator<Person>() {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.age, p2.age);
    }
};

Set<Person> people = new TreeSet<>(Person.ageComparator);

//TreeMap
Map<String, Person> map = new TreeMap<>();
map.put("Alice", new Person("Alice", 30));
map.put("Bob", new Person("Bob", 25));
map.put("Charlie", new Person("Charlie", 35));

// Iterate (sorted by key)
for (String key : map.keySet()) {
    System.out.println("Key: " + key + ", Value: " + map.get(key));
}

// Add
map.put("David", new Person("David", 28));

// Delete
map.remove("Bob");

// Find
boolean containsAlice = map.containsKey("Alice"); // returns true
System.out.println("Contains Alice: " + containsAlice);

// Update (replace value for key "Charlie")
map.put("Charlie", new Person("Charlie", 36));

// Iterate again
System.out.println("Updated TreeMap:");
for (String key : map.keySet()) {
    System.out.println("Key: " + key + ", Value: " + map.get(key));
}

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println("Key: " + key + ", Value: " + value);
}

ConcurrentHashMap: Thread-safe with high concurrency. Allows concurrent modifications without explicit synchronization.

Fail-Fast
Definition: Fail-Fast is an approach where the collection detects if it has been modified concurrently while iterating, and immediately throws a ConcurrentModificationException to prevent potential inconsistencies.
Usage: Primarily used in non-concurrent collections (e.g., ArrayList, HashMap) where modifications during iteration can lead to unpredictable behavior.
Characteristics:
Immediate Failure: Upon detecting concurrent modification, such as adding or removing elements while iterating, the iterator fails by throwing an exception.
Early Detection: Ensures that any potential issues due to concurrent modifications are identified early during iteration.
Single Thread Focus: Typically associated with single-threaded environments or collections not designed for concurrent modifications.
Fail-Safe
Definition: Fail-Safe is an approach where the collection allows iteration to continue even if the underlying collection is modified concurrently. It does not throw exceptions during iteration.
Usage: Commonly used in concurrent collections (e.g., ConcurrentHashMap, CopyOnWriteArrayList) where multiple threads can modify the collection concurrently.
Characteristics:
Safe Iteration: Ensures that modifications to the collection by other threads do not cause the iterator to fail or throw exceptions.
Snapshot Iteration: Iterators work on a snapshot of the collection taken at the time of creation, ensuring that modifications do not affect ongoing iterations.
Thread Safety: Designed to handle concurrent modifications gracefully, without requiring external synchronization.

Multithreading:
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread " + Thread.currentThread().getId() + " is running.");
    }

    public static void main(String[] args) {
        int n = 5; // Number of threads
        for (int i = 0; i < n; i++) {
            MyThread thread = new MyThread();
            thread.start();
        }
    }
}


class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread " + Thread.currentThread().getId() + " is running.");
    }

    public static void main(String[] args) {
        int n = 5; // Number of threads
        for (int i = 0; i < n; i++) {
            Thread thread = new Thread(new MyRunnable());
            thread.start();
        }
    }
}

import java.util.concurrent.*;

class MyCallable implements Callable<String> {
    public String call() {
        return "Thread " + Thread.currentThread().getId() + " is running.";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        int n = 5; // Number of threads
        ExecutorService executor = Executors.newFixedThreadPool(n);

        // Submit tasks
        for (int i = 0; i < n; i++) {
            Future<String> future = executor.submit(new MyCallable());
            System.out.println(future.get()); // Get result from Callable
        }

        executor.shutdown();
    }
}

import java.util.concurrent.*;

class MyCallable implements Callable<String> {
    public String call() {
        return "Thread " + Thread.currentThread().getId() + " is running.";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        int n = 5; // Number of threads
        ExecutorService executor = Executors.newFixedThreadPool(n);

        // Submit tasks
        for (int i = 0; i < n; i++) {
            Future<String> future = executor.submit(new MyCallable());
            System.out.println(future.get()); // Get result from Callable
        }

        executor.shutdown();
    }
}

Certainly! You can use lambda expressions in Java to achieve multi-threading as well. Lambda expressions provide a concise way to define anonymous functions, which can be passed around as method arguments or assigned to variables. Here’s how you can use lambda expressions for multi-threading:

Example: Using Lambda for Multi-Threading
java
Copy code
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class LambdaMultiThreading {
    public static void main(String[] args) {
        int n = 5; // Number of threads
        ExecutorService executor = Executors.newFixedThreadPool(n);

        // Submit tasks using lambda expression
        for (int i = 0; i < n; i++) {
            int finalI = i;
            executor.submit(() -> {
                System.out.println("Thread " + Thread.currentThread().getId() + " is running with lambda: " + finalI);
            });
        }

        executor.shutdown();
    }
}
Explanation
Lambda Expression: In the example above, the lambda expression () -> { ... } is used inside the executor.submit() method call. This lambda expression represents the task that will be executed by each thread.

ExecutorService: Executors.newFixedThreadPool(n) creates a fixed-size thread pool with n threads. Each thread in the pool executes tasks submitted via executor.submit().

Thread Identifier: Thread.currentThread().getId() retrieves the ID of the current thread, which helps identify which thread is executing the lambda expression.

Closure: The finalI variable is effectively final or "effectively final" within the lambda expression, allowing it to be used safely. Lambda expressions can capture local variables from the enclosing scope as long as those variables are effectively final.


What are checked exceptions and unchecked exceptions in Java?

Checked exceptions: Must be declared in a method's throws clause or handled using try-catch. Examples include IOException.
Unchecked exceptions: Do not need to be declared or caught explicitly. Examples include NullPointerException, ArrayIndexOutOfBoundsException.
What is the difference between throw and throws in Java?

throw is used to explicitly throw an exception within a method:
java
Copy code
throw new SomeException("Error message");
throws is used in method signatures to declare that the method may throw certain exceptions:
java
Copy code
public void method() throws SomeException {
    // Method implementation
}

Synchronization and Multithreading Questions
What is synchronization in Java multithreading?

Synchronization in Java ensures that only one thread can access a block of code or an object’s method at a time to prevent data corruption.
How can you achieve synchronization in Java?

Synchronization can be achieved using the synchronized keyword:
java
Copy code
public synchronized void synchronizedMethod() {
    // Synchronized method implementation
}
What are the different ways to implement synchronization?

Using synchronized methods, synchronized blocks with explicit locks (e.g., ReentrantLock), 
and using atomic classes from the java.util.concurrent package (e.g., AtomicInteger).
What are race conditions? How can they be prevented?

Race conditions occur when multiple threads access shared data concurrently, potentially leading to inconsistent state.
They can be prevented using synchronization mechanisms like locks or atomic operations.

Explain the volatile keyword in Java.
The volatile keyword ensures that a variable's value is always read from and written to main memory,
 avoiding thread-specific caches. It's used for variables accessed by multiple threads without synchronization.

 Integer.MAX_VALUE=Default max value


import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// Define the custom annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyCustomAnnotation {
    String value() default "default value";
    int number() default 0;
}


@Retention(RetentionPolicy.RUNTIME): This specifies that the annotation will be available at runtime.
@Target(ElementType.METHOD): This indicates that the annotation can only be applied to methods.
The annotation has two elements: value and number, both with default values.

public class MyClass {

    @MyCustomAnnotation(value = "Custom Value", number = 42)
    public void myAnnotatedMethod() {
        System.out.println("This method is annotated with MyCustomAnnotation");
    }

    @MyCustomAnnotation
    public void anotherAnnotatedMethod() {
        System.out.println("This method is also annotated with MyCustomAnnotation");
    }
}


import java.lang.reflect.Method;

public class AnnotationProcessor {

    public static void main(String[] args) {
        try {
            Class<?> clazz = MyClass.class;
            Method[] methods = clazz.getDeclaredMethods();

            for (Method method : methods) {
                if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
                    MyCustomAnnotation annotation = method.getAnnotation(MyCustomAnnotation.class);
                    System.out.println("Method: " + method.getName());
                    System.out.println("Value: " + annotation.value());
                    System.out.println("Number: " + annotation.number());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


Reflection: The AnnotationProcessor class uses Java reflection to inspect the methods of MyClass.
Annotation Retrieval: It checks if each method is annotated with @MyCustomAnnotation using method.isAnnotationPresent(MyCustomAnnotation.class).
Annotation Values: If the annotation is present, it retrieves the values of the annotation elements and prints them.


Java Reflection is a powerful API that allows you to inspect and manipulate the runtime behavior of applications. 
It provides the ability to examine or modify the runtime behavior of applications by allowing you to inspect classes, interfaces
, fields, and methods at runtime, without knowing the names of the classes, methods, etc., at compile time.

Key Uses of Reflection
Inspect Classes, Methods, and Fields at Runtime:
You can find out what methods, fields, and constructors a class has, their modifiers, parameter types, return types, and more.

Invoke Methods Dynamically:
Reflection allows you to call methods at runtime even if you don’t know their names at compile time.

Create Instances of Classes Dynamically:
You can create instances of classes at runtime, which can be particularly useful for frameworks and libraries.

Access and Modify Private Members:
Reflection allows you to bypass normal access control checks, enabling you to access private fields and methods.

Example: Basic Reflection Operations
Here is an example that demonstrates how to use Java Reflection to inspect and manipulate a class at runtime:


public class Person {
    private String name;
    private int age;

    //getters and setters
}

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionExample {
    public static void main(String[] args) {
        try {
            // Get Class object
            Class<?> personClass = Class.forName("Person");

            // Create an instance using the default constructor
            Constructor<?> constructor = personClass.getConstructor();
            Object person = constructor.newInstance();

            // Access and modify private field 'name'
            Field nameField = personClass.getDeclaredField("name");
            nameField.setAccessible(true); // Bypass access control checks
            nameField.set(person, "John Doe");

            // Access and modify private field 'age'
            Field ageField = personClass.getDeclaredField("age");
            ageField.setAccessible(true);
            ageField.setInt(person, 30);

            // Call public method 'getName'
            Method getNameMethod = personClass.getMethod("getName");
            String name = (String) getNameMethod.invoke(person);
            System.out.println("Name: " + name);

            // Call private method 'printDetails'
            Method printDetailsMethod = personClass.getDeclaredMethod("printDetails");
            printDetailsMethod.setAccessible(true);
            printDetailsMethod.invoke(person);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
Explanation of Reflection Example
Get Class Object:
Class<?> personClass = Class.forName("Person");Loads the Person class and returns its Class object.

Create an Instance Using the Default Constructor:
Constructor<?> constructor = personClass.getConstructor();
Object person = constructor.newInstance();
Uses the default constructor to create an instance of Person.

Access and Modify Private Fields:
Field nameField = personClass.getDeclaredField("name");
nameField.setAccessible(true);
nameField.set(person, "John Doe");
Accesses the private field name and modifies its value.

Call Public Method:
Method getNameMethod = personClass.getMethod("getName");
String name = (String) getNameMethod.invoke(person);
Calls the public method getName and retrieves its value.

Call Private Method:
Method printDetailsMethod = personClass.getDeclaredMethod("printDetails");
printDetailsMethod.setAccessible(true);
printDetailsMethod.invoke(person);
Calls the private method printDetails to print the details of the Person object.

When to Use Reflection

Reflection is a powerful feature, but it should be used judiciously. It is typically used in scenarios such as:

Frameworks and Libraries:
Frameworks like Spring and Hibernate use reflection to inspect and manipulate application code dynamically.

Testing and Mocking:
Testing frameworks like JUnit and Mockito use reflection to create mock objects and inject dependencies.

Serialization and Deserialization:
Libraries like Jackson and Gson use reflection to serialize and deserialize objects to and from JSON.

Downsides of Reflection
Performance Overhead:
Reflection operations are generally slower than their non-reflective counterparts due to additional processing.

Security Restrictions:
Reflection requires permissions that might be restricted in certain environments, like applets or security-sensitive applications.

Complexity and Maintainability:
Code that uses reflection is harder to understand and maintain, as it bypasses compile-time checks and relies on runtime checks.


In Java, one can apply the final keyword to a variable, methods, and class. With the help of the final keyword,
 the variable turns out to be a constant, 
the method cannot be inherited and 
the class cannot be overridden.


Yes, there is a possibility that the ‘finally’ block cannot get executed. Here are some of the cases where the above situation occurs.

During the time of fatal errors such as memory exhaustion, memory access error, etc.
During the time of using System.exit()


Worst-case time complexities of all Java built-in methods including String, StringBuilder, List classes, Set classes, Map classes, Queue classes, Stack, Arrays, and Collections classes:

String

new String("str") instantiation with value -> O(n)
"str1" + "str2" concatenation -> O(n), better solution is String concat(String str) with O(n)
int length() -> O(1)
char charAt(int index) -> O(1)
int indexOf(int ch), int indexOf(int ch, int fromIndex), int indexOf(String str), int indexOf(String str, int fromIndex), int lastIndexOf(int ch), int lastIndexOf(int ch, int fromIndex), int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex) -> O(n)
String substring(int beginIndex), String substring(int beginIndex, int endIndex) -> O(n)
String toLowerCase(), String toUpperCase() -> O(n)
boolean contains(CharSequence charSeq) -> O(n)
boolean equals(Object obj), boolean equalsIgnoreCase(String str) -> O(n)
boolean startsWith(String prefix), boolean endsWith(String suffix) -> O(n)
String replace(char oldChar, char newChar), String replace(CharSequence target, CharSequence replacement), String replaceAll(String regex, String replacement) -> O(n)
String[] split(String regex), String[] split(String regex, int limit) -> O(n)
char[] toCharArray() -> O(n)
boolean isEmpty() -> O(1)
boolean isBlank() -> O(n)
String strip(), String stripLeading(), String stripTrailing(), String trim(), String indent(int numberSpaces), String stripIndent(), String translateEscapes() -> O(n)
String format(String format, Object args...), String formatted(Object args...) -> O(n)
StringBuilder

new StringBuilder("sb") instantiaton with value -> O(n)
StringBuilder append(String str) -> O(n)
StringBuilder append(int i), StringBuilder append(double d), etc. other append methods -> O(1)
StringBuilder insert(int offset, String str) -> O(n)
StringBuilder delete(int startIndex, int endIndex), StringBuilder deleteCharAt(int index) -> O(n)
StringBuilder replace(int startIndex, int endIndex, String newString) -> O(n)
StringBuilder reverse() -> O(n)
void setCharAt(int index, char ch) -> O(1)
String substring(int beginIndex), String substring(int beginIndex, int endIndex) -> O(n)
int length() - O(1)
char charAt(int index) -> O(1)
String toString() -> O(n)
ArrayList (implements List interface)

E get(int index) -> O(1)
E remove(int index) -> O(n) with n/2 steps on average
boolean remove(E element) -> O(n)
Iterator.remove() -> O(n) with n/2 steps on average
void add(int index, E element) -> O(n) with n/2 steps on average
boolean add(E element) appending -> O(1)
ListIterator.add(E element) -> O(n) with n/2 steps on average
boolean contains(Object o) -> O(n)
E set(int index, E Element) -> O(1)
int indexOf(Object o), int lastIndexOf(Object o) -> O(n)
void clear() -> O(n)
int size() -> O(1)
boolean isEmpty() -> O(1)
LinkedList (implements List and Deque interfaces)

E get(int index) -> O(n) with n/4 steps on average, O(1) when index=0 or index=list.size()-1
E remove(int index) -> O(n) with n/4 steps on average, O(1) when index=0 or index=list.size()-1
boolean remove(E element) -> O(n)
Iterator.remove() -> O(1)
void add(int index, E element) -> O(n) with n/4 steps on average, O(1) when index=0 or index=list.size()-1
boolean add(E element) appending -> O(1)
ListIterator.add(E element) -> O(1)
boolean contains(Object o) -> O(n)
E set(int index, E Element) -> O(n)
int indexOf(Object o), int lastIndexOf(Object o) -> O(n)
void clear() -> O(n)
int size() -> O(1)
boolean isEmpty() -> O(1)
In summary ArrayList vs LinkedList:

access to front -> O(1) vs O(1)
access to back -> O(1) vs O(1)
access to middle -> O(1) vs O(n)
insert at front -> O(n) vs O(1)
insert at back (appending) -> O(1) vs O(1)
insert at middle using add(int index, E element) method -> O(n) with n/2 steps on average vs O(n) with n/4 steps on average
HashSet (implements Set interface)

boolean add(E element) appending -> O(1)
boolean contains(Object o) -> O(1)
boolean remove(Object o) -> O(1)
int size() -> O(1)
boolean isEmpty() -> O(1)
void clear() -> O(n)
Object[] toArray() -> O(n)
TreeSet (implements Set interface)

boolean add(E element) appending -> O(logn)
boolean contains(Object o) -> O(logn)
boolean remove(Object o) -> O(logn)
int size() -> O(1)
boolean isEmpty() -> O(1)
void clear() -> O(n)
E first() -> O(logn)
E last() -> O(logn)
E lower(E element) -> O(logn)
E higher(E element) -> O(logn)
E floor(E element) -> O(logn)
E ceiling(E element) -> O(logn)
Object[] toArray() -> O(n)
HashMap (implements Map interface)

boolean containsKey(Object key) -> O(n), average-case complexity is Θ(1)
boolean containsValue(Object value) -> O(n)
V get(Object key), V getOrDefault(Object key, V defaultValue) -> O(n), average-case complexity is Θ(1)
V put(K key, V value), V putIfAbsent(K key, V value) -> O(n), average-case complexity is Θ(1)
V remove(Object key) -> O(n), average-case complexity is Θ(1)
boolean remove(Object key, Object value) -> O(n), average-case complexity is Θ(1)
V replace(K key, V value) -> O(n), average-case complexity is Θ(1)
boolean replace(K key, V oldValue, V newValue) -> O(n), average-case complexity is Θ(1)
int size() -> O(1)
boolean isEmpty() -> O(1)
void clear() -> O(n)
Set keySet() -> O(1)
Collection values() -> O(1)
Set<Map.Entry<K, V>> entrySet() -> O(1)
TreeMap (implements Map interface)

boolean containsKey(Object key) -> O(logn)
boolean containsValue(Object value) -> O(n)
V get(Object key), V getOrDefault(Object key, V defaultValue) -> O(logn)
V put(K key, V value), V putIfAbsent(K key, V value) -> O(logn)
V remove(Object key) -> O(logn)
int size() -> O(1)
boolean isEmpty() -> O(1)
void clear() -> O(n)
Set keySet() -> O(1)
Collection values() -> O(1)
Set<Map.Entry<K, V>> entrySet() -> O(1)
K firstKey() -> O(logn)
K lastKey() -> O(logn)
K lowerKey(K key) -> O(logn)
K floorKey(K key) -> O(logn)
K ceilingKey(K key) -> O(logn)
K higherKey(K key) -> O(logn)
PriorityQueue (implements Queue interface)

boolean add(E element), boolean offer(E element) appending -> O(logn)
E element(), E peek() read from front -> O(1)
E remove(), E poll() get and remove from front -> O(logn)
int size() -> O(1)
ArrayDeque (implements Deque interface)

void addFirst(E element), boolean offerFirst(E element), void push(E element) add to front -> O(1)
boolean add(E element), boolean offer(E element), void addLast(E element), boolean offerLast(E element) add to back -> O(1)
E element(), E peek(), E getFirst(), E peekFirst() read from front -> O(1)
E getLast(), E peekLast() read from back -> O(1)
E remove(), E poll(), E removeFirst(), E pollFirst(), E pop() get and remove from front -> O(n)
E removeLast(), E pollLast() get and remove from back -> O(n)
int size() -> O(1)
Stack (extends Vector class and implements List interface)

E push(E item) -> O(1)
E pop() -> O(1)
E peek() -> O(1)
boolean empty() -> O(1)
int search(Object o) -> O(n)
Arrays

void sort(int[] a) -> O(nlogn)
void sort(int[] a, int fromIndex, int toIndex) -> O(nlogn)
int binarySearch(int[] a, int key) -> O(logn)
List asList(T... arr) -> O(1)
void fill(int[] a, int val) -> O(n)
int compare(int[] a, int[] b) -> O(n)
String toString(int[] a) -> O(n)
int[] copyOf(int[] original, int newLength) -> O(n)
int[] copyOfRange(int[] original, int from, int to) -> O(n)
Collections

void sort(List list) -> O(nlogn)
T max(Collection<? extends T> coll) -> O(n)
T min(Collection<? extends T> coll) -> O(n)
void shuffle(List<?> list) -> O(n)
void fill(List<? super T> list, T obj) -> O(n)
void rotate(List<?> list, int distance) -> O(n)


Multiset Implmentation in Java.
class Solution {
    public static int[] removeOrder(int n, int[] arr, String str) {
        // code here
        int sol[]=new int[n];
        TreeMap<Integer,Integer> treeMap=new TreeMap<Integer,Integer>();
        for(int i=0;i<n;i++){
            if(treeMap.containsKey(arr[i])==false){
                treeMap.put(arr[i],0);
            }
            
            treeMap.put(arr[i],treeMap.get(arr[i])+1);
        }
        
        
        
        for(int i=0;i<n;i++){
            if(str.charAt(i)=='1'){
                sol[i]=treeMap.lastKey();
            }else{
                sol[i]=treeMap.firstKey();
            }
            
            treeMap.put(sol[i],treeMap.get(sol[i])-1);
            if(treeMap.get(sol[i])==0){
                treeMap.remove(sol[i]);
            }
        }
        return sol;
    }
}
