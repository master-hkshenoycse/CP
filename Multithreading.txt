Thread share resources with other thread.
Daemon thread-Infrastructure thread like garbage collector,event dispatcher are examples.
Non daemon/user thread-perform program task, main thread is non daemon.
Newly created thread inherits daemon status from parent thread.
so, all threads created inside main methods are non-daemon by default.
can be set by setDaemon(true), should be called before thread starting.
JVM gives higher priority to non-daemon threads.
JVM waits for all non-daemon threads to finish before closing itself.
JVM  terminates daemon thread.

Java thread is instance of java.lang.thread class.
attributes-id,name,priority,state.
behaviour-start(),sleep(),join(),interrupt();

Running behaviour of thread represneted by java.lang.Runnable interface.
interface has only one method run().
this method contains the block of code that's executed as thread.
java.lang.Thread class implements the runnable interface.


Two ways to create java threads:
extend thread,implement runnable.

dont call run() method to execute the thread, call start() method,
if thread is used by creating extends thread class, then no other class can be extended as java does not support multiple inhertitance


extend thread is inhertitance, tight coupling.
Implemeting runnable is loose coupled.


Sleep() a static method to interurpt the execution.

thread goes from runnable to waiting state.

Thread interruption in java.
internal flag -interrupted status.
interrupt()-Instance methods.
interrupted()-static method-Return true is the thread has been interrupted by an interrupt() call, and clears the interrupt event,
can be called without thread reference.
isInterrupted-Instance method- returns current value of interrupted status flag.
.

Handle interrupts in try catch block.
try{
    Thread.sleep(1000);
}catch(InterruptedException e){
     break;
}


join() - blocking method, wait until another thread finishes.
Calling the _____ method on a thread can cause other threads to wait until it finishes execution.

in main 
marksThread.join() try catch Interrupted exception.
in above the Main thread will wait until marksThread is finished executing.

getId() - Id generatedat time of created.
getName()


It's possible to respond to an interruption request when no InterruptedException is thrown with the help of the static interrupted() method. Call Thread.interrupted() to check if the interrupted status flag is true. If itâ€™s true, it means that the thread has received a request to interrupt its task. Then you can terminate the long running task.


stack holds primitives and refernces.
heap stores object- reference points to objects in heap.
thread stack is private to thread, threads shares the heap.

Data Race condition
volatile keyword provides  protection from data races,gurantees visiblity ogf shared data by reading and writing from/to main memory.
Does not lock a shared piece of data.
Using the volatile keyword on variables that are shared by multiple threads, could help prevent Data Races to some extent. But this visibility guarantee is not sufficient when threads that share a piece of data are not just reading but also writing. There should be some locking mechanism to prevent simultaneous access to shared data.
Synchronized keyword to mark critical sections.

every Java object has a monitor object assosicated with it.
monior has a lock which protects the critical section if code.
One thread at a time can hold a lock on monitor , other threads stay blocked.

synchronized can be used on static methods.
locking smaller section of code is better.
may cause performance overheads, deadlocks and startvation.

The synchronized keyword can be used on a block of code or on a method but not on a class. 
Class-level synchronization can be achieved by using the synchronized keyword on a static method(s).

Code that is enclosed in a Synchronized block or method can only be executed by a single thread at a time.
This causes blocking as threads have to be blocked, as threads wait for another to finish executing syncronized code.

Main thread spans all other thread.
while the main thread is waiting for a thread to execute and return , its not able to spawn other threads at same time.

Asnychrnux non blocking.

Future Object-
Reprsents the result of an asynchronus computation.
Creating an asynchronus task returns a future object.
get(),  before calling check by isDone(),
cancel()

In Java 8 there is CompletableFuture interface
implements Future and CompletionStage interface

CompletionStage is a stage of an asyncronus progaramming.

.get() method of future blocks until results are available.
callback is a function that gets called automatically on the completion of another function.

When attached to a CompletableFuture, the caller wont need to wait blocked for the results.

Future does not handle execption.


A group of threads that can be used to execute tasks without creating and managing them for each task execution.
The sane thread can be used to exexcute more than 1 task.
controlled thread creation.
saves RAM.
manages thread lifecycle.

How a thread pool works
Application pushes task in a queue ,
Whenever a thread becomes free in thread pool , it picks the taskk from Task Queue.

Executor is a helper that creates thread pools and takes care 
of asynchornus task execution.Its like another way of creating and executing threads in Java.

Executor is a java interface.
Available in java.util.concurrent package.
Has a single method named execute().
Executes a given task or a Runnable sometimes in future.

ExecutorService is  extension of Executor- described later.


An Executor internally maintains a thread pool to avoid continous spawning of threads.
An Executor is repsonsible for executing tasks given to it with the threads available in thread pool.

ExecutorService has methods like:

submit()-same as execute() method of Executor.
Returns a Future- status and result of task execution.
has Overloaded methods:-
submit(Runnable task)-Returned future conatins a null result.
submit(Runnable task,T result)-Returned Future contains the result given in second arg.
submit(Callable<T>  task)-

invokeAll()-accepts a collection of callable taksa and returns a List of Futures,
which holds the result returned by each task when all  the asynchronus tasks are completed.

invokeAny()

shutdown()
awaitTermination(timeout,Timeunit)- wait until all tasks have completed execution after shutdown request.
or given timeuout occurs, or the current thread is interupted.


Schduling Tasks in an application:
for later execution

Two ways of schduling tasks:
Execute a task after period of time.
Execute a task periodically.
SchduleExecutorService.
schdule()- Takes a Runnable or a callable task and a delay.
the task is executed after the given delay in time.

schduleAtFixedRate()-If an execution takes longer than the given period subsequent executions may start late, after the previous run is complete.
schduleAtFixedDelay()-Allows a fixed length delay betweeen iterations of the task.


Fork join framework of java, helps developers to take advantage of paralle processing 
backed by multicore processors/multiple CPU cores.

It is implemntation of ExecutorService interface.

fork- task split into smaller indepnedent subtask.
join - main task waits untill all subtask have been completed.

Fork.join framework takes care of
Forking,computing,joining.

Parallel Streams uses fork/join framework.
and in method Arrays.parallelSort().

Worker Threads:
Worker thread in Fork/Join pool keep looking for tasks/subtasks to execute.
The idea is to keep wotker thread as busy as possible.
Each worker thread in Fork/join pool has a deque called work queue.
Client and worker thread pool shares a queue.

If worker thread finds its queue has some space, then it randomly checks 
the work queue of other worker threads to take their work
this is called work stealing- in FIFO
task of it own- LIFO.

Core classes of framework:
ForkJoinPool- Facilitites parallel execution using work-stealing algo.
Methods called by client: 
execute(ForkJoinTask task)-asynchronusly
invoke(ForkJoinTask task)-synchronusly.
submit(ForkJoinTask task) 

ForkJoinPool.commonPool- Factory method that returns an instance of default thread pool for every FrokJoinTask.
When above methods are called task first goes into shared global queue.

ForkJoinTask.
Methods:
fork()- submit the task to execute async and return it.
join()- Waits until the task is done 
invoke()- combines both above in single call.


RecursiveAction- doesnt return, runnable 
RecursiveTask.-return  , callable.
has a abstract compute() method.

Synchronized collections:-

Collection is wrapped in synchronized wrapper.
All methods of collection objects are synchronized.
Wrapper keeps a mutex and locks the collection before each operation.
Object level synchornization, means entire collection is locked.
Iterator is not thread safe -still needs to be done manually.


Concurrent Collections-
lock stripping. allows mutiple threads to access other segments of same ConcurrentHashMap.
as locking is dobe on segment level.

