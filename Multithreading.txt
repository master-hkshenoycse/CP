Thread share resources with other thread.
Daemon thread-Infrastructure thread like garbage collector,event dispatcher are examples.
Non daemon/user thread-perform program task, main thread is non daemon.
Newly created thread inherits daemon status from parent thread.
so, all threads created inside main methods are non-daemon by default.
can be set by setDaemon(true), should be called before thread starting.
JVM gives higher priority to non-daemon threads.
JVM waits for all non-daemon threads to finish before closing itself.
JVM  terminates daemon thread.

Java thread is instance of java.lang.thread class.
attributes-id,name,priority,state.
behaviour-start(),sleep(),join(),interrupt();

Running behaviour of thread represneted by java.lang.Runnable interface.
interface has only one method run().
this method contains the block of code that's executed as thread.
java.lang.Thread class implements the runnable interface.


Two ways to create java threads:
extend thread,implement runnable.

dont call run() method to execute the thread, call start() method,
if thread is used by creating extends thread class, then no other class can be extended as java does not support multiple inhertitance


extend thread is inhertitance, tight coupling.
Implemeting runnable is loose coupled.


Sleep() a static method to interurpt the execution.

thread goes from runnable to waiting state.

Thread interruption in java.
internal flag -interrupted status.
interrupt()-Instance methods.
interrupted()-static method-Return true is the thread has been interrupted by an interrupt() call, and clears the interrupt event,
can be called without thread reference.
isInterrupted-Instance method- returns current value of interrupted status flag.
.

Handle interrupts in try catch block.
try{
    Thread.sleep(1000);
}catch(InterruptedException e){
     break;
}


join() - blocking method, wait until another thread finishes.
Calling the _____ method on a thread can cause other threads to wait until it finishes execution.

in main 
marksThread.join() try catch Interrupted exception.
in above the Main thread will wait until marksThread is finished executing.

getId() - Id generatedat time of created.
getName()


It's possible to respond to an interruption request when no InterruptedException is thrown with the help of the static interrupted() method. Call Thread.interrupted() to check if the interrupted status flag is true. If itâ€™s true, it means that the thread has received a request to interrupt its task. Then you can terminate the long running task.


stack holds primitives and refernces.
heap stores object- reference points to objects in heap.
thread stack is private to thread, threads shares the heap.

Data Race condition
volatile keyword provides  protection from data races,gurantees visiblity ogf shared data by reading and writing from/to main memory.
Does not lock a shared piece of data.
Using the volatile keyword on variables that are shared by multiple threads, could help prevent Data Races to some extent. But this visibility guarantee is not sufficient when threads that share a piece of data are not just reading but also writing. There should be some locking mechanism to prevent simultaneous access to shared data.
Synchronized keyword to mark critical sections.

every Java object has a monitor object assosicated with it.
monior has a lock which protects the critical section if code.
One thread at a time can hold a lock on monitor , other threads stay blocked.

synchronized can be used on static methods.
locking smaller section of code is better.
may cause performance overheads, deadlocks and startvation.

The synchronized keyword can be used on a block of code or on a method but not on a class. 
Class-level synchronization can be achieved by using the synchronized keyword on a static method(s).

Code that is enclosed in a Synchronized block or method can only be executed by a single thread at a time.
This causes blocking as threads have to be blocked, as threads wait for another to finish executing syncronized code.

Main thread spans all other thread.
while the main thread is waiting for a thread to execute and return , its not able to spawn other threads at same time.

Asnychrnux non blocking.

Future Object-
Reprsents the result of an asynchronus computation.
Creating an asynchronus task returns a future object.
get(),  before calling check by isDone(),
cancel()

In Java 8 there is CompletableFuture interface
implements Future and CompletionStage interface
